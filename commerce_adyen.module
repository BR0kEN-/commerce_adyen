<?php
/**
 * @file
 * Commerce Adyen.
 */

define('COMMERCE_ADYEN_BASE_URL', 'commerce/adyen');
define('COMMERCE_ADYEN_PAYMENT_METHOD', 'commerce_adyen');
define('COMMERCE_ADYEN_PAYMENT_METHOD_INSTANCE', sprintf('%s|commerce_payment_%1$s', COMMERCE_ADYEN_PAYMENT_METHOD));

/**
 * Implements hook_menu().
 */
function commerce_adyen_menu() {
  $info = [];

  // For "response" we will have GET request and "POST" for "notification".
  $info[COMMERCE_ADYEN_BASE_URL] = [
    'type' => MENU_CALLBACK,
    'file' => 'includes/commerce_adyen.menu.inc',
    'page callback' => 'commerce_adyen_controller',
    'delivery callback' => 'commerce_adyen_deliver',
    'page arguments' => [count(explode('/', COMMERCE_ADYEN_BASE_URL))],
    'access arguments' => TRUE,
  ];

  return $info;
}

/**
 * Implements hook_commerce_payment_method_info().
 */
function commerce_adyen_commerce_payment_method_info() {
  $info = [];

  $info[COMMERCE_ADYEN_PAYMENT_METHOD] = [
    'file' => 'includes/commerce_adyen.payment.inc',
    'title' => 'Adyen',
    'description' => t('Redirect users to submit payments through Adyen.'),
    'active' => TRUE,
    'terminal' => FALSE,
    'offsite' => TRUE,
    'offsite_autoredirect' => TRUE,
  ];

  return $info;
}

/**
 * Implements hook_commerce_adyen_responses().
 */
function commerce_adyen_commerce_adyen_responses() {
  return [
    \Commerce\Adyen\Response\Payment::class,
    \Commerce\Adyen\Response\Notification::class,
  ];
}

/**
 * Collect Adyen response types.
 *
 * @see hook_commerce_adyen_responses()
 *
 * @return \Commerce\Adyen\ResponseInterface[]
 *   A list of response types.
 */
function commerce_adyen_responses() {
  /* @var \Commerce\Adyen\ResponseInterface[] $requests */
  $requests = module_invoke_all(__FUNCTION__);

  // Remove duplicates.
  array_unique($requests);

  foreach ($requests as $i => $class) {
    unset($requests[$i]);

    if (isset(class_implements($class)[\Commerce\Adyen\ResponseInterface::class])) {
      $requests[$class::type()] = $class;
    }
  }

  return $requests;
}

/**
 * Returns the URL of Adyen endpoint.
 *
 * @param string $mode
 *   Allowed values are: "test" and "live".
 * @param string $operation
 *   Operation type.
 *
 * @return string
 *   Server URL.
 */
function commerce_adyen_url($mode, $operation) {
  switch ($operation) {
    // @link https://docs.adyen.com/developers/hpp-manual#hppendpoints
    case 'create':
      return "https://$mode.adyen.com/hpp/pay.shtml";

    // @link https://docs.adyen.com/developers/hpp-manual#hppendpoints
    case 'capture':
      return "https://pal-$mode.adyen.com/pal/adapter/httppost";
  }

  throw new \RuntimeException(t('Operation is not supported!'));
}

/**
 * Calculate merchant signature.
 *
 * @param array $data
 *   Payment data.
 * @param string $algorithm
 *   One of encoding algorithms.
 * @param string $hmac
 *   HMAC signature from Adyen backend.
 * @param string $operation
 *   Available values are: "response", "request".
 *
 * @return string
 *   Merchant signature.
 */
function commerce_adyen_hmac_signature(array $data, $algorithm, $hmac, $operation) {
  switch ($algorithm) {
    case 'sha256':
      $escapeval = function ($value) {
        return strtr($value, [':' => '\\:', '\\' => '\\\\']);
      };

      // @todo Is "response" operation available only for "sha256"?
      if ('response' === $operation) {
        unset($data['merchantSig']);
      }

      ksort($data, SORT_STRING);

      // Generate the signing data string.
      $sign = implode(':', array_map($escapeval, array_merge(array_keys($data), array_values($data))));
      // Encode binary result of the HMAC computation.
      return base64_encode(hash_hmac($algorithm, $sign, pack('H*', $hmac), TRUE));

    case 'sha1':
      $keys = ['authResult', 'pspReference', 'merchantReference', 'skinCode', 'merchantReturnData'];
      $sign = '';

      if ('request' === $operation) {
        // "shopperLocale" and "resURL" are passed as a parameters
        // and not used in the signing string.
        unset($data['shopperLocale'], $data['resURL']);
        // The signature is generated by concatenating the values of a number
        // of the payment session fields.
        $keys = array_keys($data);
      }

      foreach ($keys as $key) {
        if (isset($data[$key])) {
          $sign .= $data[$key];
        }
      }

      return base64_encode(pack('H*', hash_hmac($algorithm, $sign, $hmac)));
  }

  return '';
}

/**
 * Capture request. Used as callback for action of a "rules".
 *
 * @todo Should this function be more generic?
 * @see commerce_adyen_rules_action_info()
 *
 * @param \stdClass $order
 *   Commerce order.
 */
function commerce_adyen_capture_request(\stdClass $order) {
  if (!empty($order)) {
    $payment_transactions = commerce_payment_transaction_load_multiple([], [
      'order_id' => $order->order_id,
      'instance_id' => COMMERCE_ADYEN_PAYMENT_METHOD_INSTANCE,
      'remote_status' => 'authorised',
      'payment_method' => COMMERCE_ADYEN_PAYMENT_METHOD,
    ]);

    if (!empty($payment_transactions)) {
      $payment_transaction = reset($payment_transactions);
      $payment_method = commerce_payment_method_instance_load($payment_transaction->instance_id);

      // Required parameter.
      // @link https://docs.adyen.com/developers/api-manual#capture
      $request = [
        // In this case, it's the capture payment: Payment.capture.
        'action' => 'Payment.capture',
        // The merchant account the payment was processed with.
        'modificationRequest.merchantAccount' => $payment_method['settings']['merchant_account'],
        // The amount to capture.
        'modificationRequest.modificationAmount.currency' => $payment_transaction->currency_code,
        'modificationRequest.modificationAmount.value' => $payment_transaction->amount,
        // This is the pspReference that was assigned to the authorisation.
        'modificationRequest.originalReference' => $payment_transaction->remote_id,
      ];

      // @todo Why not drupal_http_request()?
      $ch = curl_init();

      curl_setopt($ch, CURLOPT_URL, commerce_adyen_url($payment_method['settings']['mode'], 'capture'));
      curl_setopt($ch, CURLOPT_HEADER, FALSE);
      curl_setopt($ch, CURLOPT_HTTPAUTH, CURLAUTH_BASIC);
      curl_setopt($ch, CURLOPT_USERPWD, $payment_method['settings']['client_user'] . ':' . $payment_method['settings']['client_password']);
      curl_setopt($ch, CURLOPT_POST, count($request));
      curl_setopt($ch, CURLOPT_POSTFIELDS, http_build_query($request));
      curl_setopt($ch, CURLOPT_RETURNTRANSFER, TRUE);

      $result = curl_exec($ch);
      $error = curl_error($ch);

      if (empty($result) || '' !== $error) {
        watchdog(COMMERCE_ADYEN_PAYMENT_METHOD, $error, [], WATCHDOG_ERROR);

        $payment_transaction->status = COMMERCE_PAYMENT_STATUS_FAILURE;
        $payment_transaction->message = $error;

        commerce_payment_transaction_save($payment_transaction);
        commerce_order_status_update($order, LUSH_ORDER_STUCK_STATUS);
      }
      else {
        parse_str($result, $result);

        if ('[capture-received]' === $result['modificationResult_response']) {
          watchdog(COMMERCE_ADYEN_PAYMENT_METHOD, 'Transaction has been captured.', [], WATCHDOG_INFO);
        }
        else {
          // @todo Should we notify about unsuccessful capturing?
        }
      }

      curl_close($ch);
    }
  }
}
